// const Timetable = require("../model/AdminTimeTableModel")
const ClassBatch = require("../model/AdminClassBatchModel")
const Timetable = require("../model/AdminTimeTableModel")
const Session = require("../model/SessionModel")
const Admin = require("../model/AdminModel")
const SpreadSheetTimeTable = require("../model/SpreadSheetTimetableModel")
const SpreadSheetFacultyTimeTable = require("../model/SpreadSheetFacultyTimetableModel")
const Student = require("../model/StudentModel")
const Faculty = require("../model/FacultyModel")
const Resource = require("../model/ResourceModel")
const GoogleSpreadsheetModel = require("../model/GoogleSpreadsheetModel")
const bcrypt = require("bcrypt")
const jwt = require('jsonwebtoken')
const moment = require('moment');

const { GoogleSpreadsheet } = require('google-spreadsheet');
const { JWT } = require('google-auth-library');

// Initialize auth - see https://theoephraim.github.io/node-google-spreadsheet/#/guides/authentication
const serviceAccountAuth = new JWT({
    // env var values here are copied from service account credentials generated by google
    // see "Authentication" section in docs for more info
    email: process.env.GOOGLE_SERVICE_ACCOUNT_EMAIL,
    key: process.env.GOOGLE_PRIVATE_KEY,
    scopes: ['https://www.googleapis.com/auth/spreadsheets'],
});

const { google } = require("googleapis");

// Initialize auth - see https://googleapis.dev/nodejs/googleapis/latest/auth/index.html
const jwtClient = new google.auth.JWT({
    email: process.env.GOOGLE_SERVICE_ACCOUNT_EMAIL,
    key: process.env.GOOGLE_PRIVATE_KEY.replace(/\\n/g, '\n'), // Replace newline characters
    scopes: ['https://www.googleapis.com/auth/spreadsheets'],
  });
  
  // Define the Google Sheets API after initialization
  const sheets = google.sheets({ version: 'v4', auth: jwtClient });

require('dotenv').config();

const createSession = async (req, res) => {
    try {
        const { academicYear, semester, times } = req.body;
    
        // Create a new session
        const newSession = new Session({
          academicYear,
          semester,
          times,
        });
    
        // Save session to the database
        await newSession.save();
    
        // Respond with success
        res.status(201).json({ message: 'Session created successfully', session: newSession });
      } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Internal server error' });
      }
}

const createClassBatch = async (req, res) => {
    const {academicYear, semester, classes, batches} = req.body;

    try {
        // Create a new instance of the Timetable model
        const newClassBatch = new ClassBatch({
            academicYear,
            semester,
            classes,
            batches
        });

        // Save the timetable to the database
        const savedClassBatch = await newClassBatch.save();

        // Send a success response
        res.status(201).json({ message: "Timetable created successfully", data: savedClassBatch });
    } catch (error) {
        // Handle any errors during saving
        res.status(500).json({ message: "Server error", error: error.message });
    }
}


const createTimeTable = async (req, res) => {
    try{
        const { academicYear, semester, selectedClass, weeklyTimetable } = req.body;

        let timetable = await Timetable.findOne({
            academicYear,
            semester,
            class: selectedClass
        });

        if (timetable) {
            timetable.weeklyTimetable = weeklyTimetable;

            await timetable.save();

            res.status(200).json({
                message: "Timetable updated successfully",
                timetable
            });
        } else{
            const newTimetable = new Timetable({
                academicYear,
                semester,
                class: selectedClass,
                weeklyTimetable
            });

            await newTimetable.save();

            res.status(201).json({
                message: "Timetable created successfully",
                timetable: newTimetable
            });
        }
    }catch (error) {
        console.error("Error creating timetable:", error);
        res.status(500).json({
            message: "Failed to create timetable",
            error: error.message
        });
    }
}


const validateAdmin = async (req, res) => {
    const { email, password } = req.body;

    if (!email || !password) {
        return res.json({ error: true, message: "Email and password are required" });
    }

    const admin = await Admin.findOne({ email: email });

    if (!admin) {
        return res.json({ error: true, message: "Invalid email" });
    }

    const match = await bcrypt.compare(password, admin.password);

    if (!match) {
        return res.json({ error: true, message: "Invalid password" });
    }

    const accessToken = jwt.sign({ adminId: admin._id, email: admin.email }, process.env.ACCESS_TOKEN_SECRET, {
        expiresIn: "1d",
    });

    return res.status(200).json({ 
        error: false,
        message: "Login successful",
        accessToken
    });
}

const validate = async (req, res) => {
    res.json({
        error: false,
        admin: req.user,
     });
}

const getTimes = async (req, res) => {
    const { academicYear, semester } = req.query;

    try {
        const session = await Session.findOne({ academicYear, semester });

        if (!session) {
            return res.json({ error: true, message: "No session found for the provided academic year and semester." });
        }

        res.status(200).json({
            times: session.times,
        });
    } catch (error) {
        // Handle any errors
        res.status(500).json({ message: "Server error", error: error.message });
    }
}


const getClasses = async (req, res) => {
    const { academicYear, semester } = req.query;

    try {
        const classBatch = await ClassBatch.findOne({ academicYear, semester });

        if (!classBatch) {
            return res.json({ error: true, message: "No class found for the provided academic year and semester." });
        }

        var classes=[];
        for(let i=0; i<classBatch.classes.length; i++){
            classes.push(classBatch.classes[i].className);
        }

        res.status(200).json({ classes: classes });
    } catch (error) {
        res.status(500).json({ message: "Server error", error: error.message });
    }
};

const getBatches = async (req, res) => {
    const { academicYear, semester, selectedClass } = req.query;

    try {
        const classBatch = await ClassBatch.findOne({ academicYear, semester });

        if (!classBatch) {
            return res.json({ error: true, message: "No class or batch found for the provided academic year and semester." });
        }

        const classData = classBatch.classes.find(cls => cls.className === selectedClass);

        if (!classData) {
            return res.json({ error: true, message: "No class found for the provided class name." });
        }

        // Return the batches array
        res.status(200).json({
            batches: classData.batches
        });
    } catch (error) {
        res.status(500).json({ message: "Server error", error: error.message });
    }
};

const addSheetId = async (req, res) => {
    const { sheetId } = req.body;

    try {
        // Delete all existing sheetIds
        await GoogleSpreadsheetModel.deleteMany({});
        await SpreadSheetTimeTable.deleteMany({});
        await SpreadSheetFacultyTimeTable.deleteMany({});
        await Student.deleteMany({});
        await Faculty.deleteMany({});
        await Resource.deleteMany({});
    
        // Add the new sheetId
        const newSheet = new GoogleSpreadsheetModel({ sheetId });
        await newSheet.save();

        // const doc = new GoogleSpreadsheet(sheetId, serviceAccountAuth);

        // await doc.loadInfo(); // loads document properties and worksheets

        // const sheet = doc.sheetsByIndex[0]; // or use `doc.sheetsById[id]` or `doc.sheetsByTitle[title]`
        
        // console.log(sheet.title);




        const spreadsheetId = sheetId;
        const response2 = await sheets.spreadsheets.get({
            spreadsheetId,
        });
        const sheetData = response2.data.sheets || [];
        const sheetNames = sheetData.map(sheet => sheet.properties.title);
        const totalSheets = sheetNames.length;

        // console.log(totalSheets+"\n"+sheetNames);

        const classes = sheetNames.filter(sheetName => /^\d/.test(sheetName));

        // console.log("Total class sheets: " + classes.length);
        // console.log("Class sheet names: ", classes);

        for (const sheet of classes) {
            await createTimeTableBasedOnSheet(sheet, "class");
        }



        const invalidSheets = ["AllStudents", "Resources", "OnlyForStudents", "Sample-Faculty", "Empty", "All_Faculties"];

        const faculties = sheetNames.filter(sheetName => {
            // Check if the sheet name is in the invalid list
            if (invalidSheets.includes(sheetName)) {
                return false;
            }

            // Check if the sheet name contains numbers
            const hasNumbers = /\d/.test(sheetName);

            // If the sheet contains numbers, check if it starts with 'TA'
            if (hasNumbers) {
                return sheetName.startsWith('TA')|| sheetName.startsWith('V');
            }

            // If the sheet does not contain numbers, it's valid
            return true;
        });

        // console.log("Total faculty sheets: " + faculties.length);
        // console.log("Faculty sheet names: ", faculties);

        for (const sheet of faculties) {
            await createTimeTableBasedOnSheet(sheet, "faculty");
        }




        async function createTimeTableBasedOnSheet(sheet, choice){
            const response = await sheets.spreadsheets.values.get({
                spreadsheetId,
                range: sheet, // Adjust according to your sheet name
              });
            const rows = response.data.values;
            // console.log(rows);
    
            var timeArray = rows[0].slice(1);
    
            // console.log(timeArray);
    
            var weeklyTimetable = {
                Monday: [],
                Tuesday: [],
                Wednesday: [],
                Thursday: [],
                Friday: [],
                Saturday: []
            }
    
            var mondaySessions = [];
            var tuesdaySessions = [];
            var wednesdaySessions = [];
            var thursdaySessions = [];
            var fridaySessions = [];
            var saturdaySessions = [];
    
            var session = { type: '', time: '', subject: '', classbatch: '', faculty: '', location: ''}
    
            function createSession(i, j){
                session = { type: '', time: '', subject: '', classbatch: '', faculty: '', location: ''}
                session.time = timeArray[j-1];
                if(rows[i][j]=="Break" || rows[i][j]=="No Teaching Load"){
                    session.type = rows[i][j];
                }else{
                    var lines = rows[i][j].split('\n').map(line => line.trim());
                    if(lines[0]){
                        session.subject = lines[0];
                    }
                    if(lines[1]){
                        session.classbatch = lines[1];
                    }
                    if(lines[2]){
                        session.faculty = lines[2];
                    }
                    if(lines[3]){
                        session.location = lines[3];
                    }
                    if(lines[4]){
                        if(lines[4]==1){
                            session.type = 'Lecture';
                        }else if(lines[4]==2){
                            session.type = 'Lab';
                        }
                    }
                }
                return session;
            }
    
            for(let i=1; i<rows.length; i++){
                if(rows[i][0]=='Monday'){
                    for(let j=1; j<rows[i].length; j++){
                        mondaySessions.push(createSession(i, j))
                    }
                    weeklyTimetable.Monday.push(mondaySessions);
                    mondaySessions = [];
                }
                else if(rows[i][0]=='Tuesday'){
                    for(let j=1; j<rows[i].length; j++){
                        tuesdaySessions.push(createSession(i, j))
                    }
                    weeklyTimetable.Tuesday.push(tuesdaySessions);
                    tuesdaySessions = [];
                }
                else if(rows[i][0]=='Wednesday'){
                    for(let j=1; j<rows[i].length; j++){
                        wednesdaySessions.push(createSession(i, j))
                    }
                    weeklyTimetable.Wednesday.push(wednesdaySessions);
                    wednesdaySessions = [];
                }
                else if(rows[i][0]=='Thursday'){
                    for(let j=1; j<rows[i].length; j++){
                        thursdaySessions.push(createSession(i, j))
                    }
                    weeklyTimetable.Thursday.push(thursdaySessions);
                    thursdaySessions = [];
                }
                else if(rows[i][0]=='Friday'){
                    for(let j=1; j<rows[i].length; j++){
                        fridaySessions.push(createSession(i, j))
                    }
                    weeklyTimetable.Friday.push(fridaySessions);
                    fridaySessions = [];
                }
                else if(rows[i][0]=='Saturday'){
                    for(let j=1; j<rows[i].length; j++){
                        saturdaySessions.push(createSession(i, j))
                    }
                    weeklyTimetable.Saturday.push(saturdaySessions);
                    saturdaySessions = [];
                }
            }
    
            // console.log("weeklyTimetable: \n" + weeklyTimetable.Monday.length);
    
            // console.log("Monday: ");
            // weeklyTimetable.Monday.forEach(day => console.log(day));
    
            // console.log("Tuesday: ");
            // weeklyTimetable.Tuesday.forEach(day => console.log(day));
    
            // console.log("Wednesday: ");
            // weeklyTimetable.Wednesday.forEach(day => console.log(day));
    
            // console.log("Thursday: ");
            // weeklyTimetable.Thursday.forEach(day => console.log(day));
    
            // console.log("Friday: ");
            // weeklyTimetable.Friday.forEach(day => console.log(day));
    
            // console.log("Saturday: ");
            // weeklyTimetable.Saturday.forEach(day => console.log(day));
    
    
            if(choice=="class"){
                const classTimetable = new SpreadSheetTimeTable({ class: sheet, weeklyTimetable });
                await classTimetable.save();
            }else if(choice == "faculty"){
                const facultyTimetable = new SpreadSheetFacultyTimeTable({ facultyName: sheet, weeklyTimetable });
                await facultyTimetable.save();
            }
        }

        

        const response3 = await sheets.spreadsheets.values.get({
            spreadsheetId,
            range: "AllStudents", // Adjust according to your sheet name
          });
        const rowsData = response3.data.values;

        const hashedPassword = await bcrypt.hash(process.env.PASSWORD, 10);
        
        for (let k=1; k<rowsData.length; k++) {
            if(rowsData[k][5] !== undefined){
                if(rowsData[k][5] !== ''){
                    const studentData = new Student({ enrollment: rowsData[k][1], name: rowsData[k][2], branch: rowsData[k][3], hostellercommuter: rowsData[k][4], semester: rowsData[k][5], phone: rowsData[k][6], parentsphone: rowsData[k][7], gnuemail: rowsData[k][8], email: rowsData[k][9], batch: rowsData[k][10], class: rowsData[k][11] , password: hashedPassword});
                    await studentData.save();
                }
                else{
                    if(rowsData[k][8] !== undefined){
                        const facultyData = new Faculty({enrollment: rowsData[k][1], name: rowsData[k][2], branch: rowsData[k][3], phone: rowsData[k][6], gnuemail: rowsData[k][8], password: hashedPassword});
                        await facultyData.save();
                    }
                    else if(rowsData[k][6] !== undefined){
                        const facultyData = new Faculty({enrollment: rowsData[k][1], name: rowsData[k][2], branch: rowsData[k][3], phone: rowsData[k][6], gnuemail: '', password: hashedPassword});
                        await facultyData.save();
                    }
                    else{
                        const facultyData = new Faculty({enrollment: rowsData[k][1], name: rowsData[k][2], branch: rowsData[k][3], phone: '', gnuemail: '', password: hashedPassword});
                        await facultyData.save();
                    }
                }
            }else{
                const facultyData = new Faculty({enrollment: rowsData[k][1], name: rowsData[k][2], branch: rowsData[k][3], phone: '', gnuemail: '', password: hashedPassword});
                await facultyData.save();
            }
        }

        
        

        const response4 = await sheets.spreadsheets.values.get({
            spreadsheetId,
            range: "Resources", // Adjust according to your sheet name
          });
        const rowsData2 = response4.data.values;
        // console.log(rowsData2);

        for(let i=1; i<rowsData2.length; i++){
            const resourceData = new Resource({location: rowsData2[i][1], acs: rowsData2[i][2], chairs: rowsData2[i][3], benches: rowsData2[i][4], computers: rowsData2[i][5], fans: rowsData2[i][6], tubelights: rowsData2[i][7], projectors: rowsData2[i][8]});
            await resourceData.save();
        }




        res.status(200).json({ message: 'Data imported successfully'});
      } catch (error) {
        console.error('Error adding sheetId:', error);
        res.status(500).json({ message: 'Error adding sheet ID', error });
      }
}


const getSheets = async (req, res) => {
  try {
    // Fetch data from both models
    const classTimetables = await SpreadSheetTimeTable.find();
    const facultyTimetables = await SpreadSheetFacultyTimeTable.find();

    // Console log the data
    // console.log('Class Timetables:', classTimetables);
    // console.log('Faculty Timetables:', facultyTimetables);

    var sheets=[];

    for(let i of classTimetables){
        sheets.push(i.class);
    }

    for(let i of facultyTimetables){
        sheets.push(i.facultyName);
    }

    // Send a response to indicate successful fetch
    res.status(200).json({
      success: true,
      message: 'Data fetched successfully',
      sheets
    });
  } catch (error) {
    console.error('Error fetching timetables:', error);

    // Send an error response if something goes wrong
    res.status(500).json({
      success: false,
      message: 'Error fetching timetables',
      error: error.message,
    });
  }
};

const getTimetableBasedOnSheetName = async (req, res) => {
    try {
      const { sheetName } = req.query;
  
    //   console.log('Received sheetName:', sheetName);

    
      let timetable;
  
      // Assuming you have two different models for class and faculty timetables
      
      /*
        timetable = await SpreadSheetTimeTable.findOne({ class: sheetName });
      
        if(!timetable){
            timetable = await SpreadSheetFacultyTimeTable.findOne({ facultyName: sheetName });
        }
      
        */

        let sheetId = await GoogleSpreadsheetModel.find();
        // console.log(sheetId[0].sheetId);
        let spreadsheetId = sheetId[0].sheetId;


        const response = await sheets.spreadsheets.values.get({
            spreadsheetId,
            range: sheetName, // Adjust according to your sheet name
          });

        timetable = response.data.values;
        // console.log(timetable);
  
        res.json({ timetable });
      
    } catch (error) {
      console.error('Error fetching timetable:', error);
      res.status(500).json({ success: false, message: 'Server error' });
    }
  };
  

  const getDayWiseTimetable = async (req, res) => {
    try {
        const { sheetName, day } = req.query;

        let timetable;
        let sheetId = await GoogleSpreadsheetModel.find();
        let spreadsheetId = sheetId[0].sheetId;
        const response = await sheets.spreadsheets.values.get({
            spreadsheetId,
            range: sheetName, // Adjust according to your sheet name
          });

        timetable = response.data.values;

        var dayWiseTimetable = [];
        dayWiseTimetable = timetable.filter((row)=> row[0]==day);
        var dayWiseTimetableData = [];
        dayWiseTimetableData.push(timetable[0]);

        for(let row of dayWiseTimetable){
            dayWiseTimetableData.push(row);
        }

        // console.log(dayWiseTimetableData);
        res.json({ dayWiseTimetableData });

    } catch (error) {
        console.log(error);
    }
  }

  const getTimetableBasedOnTime = async (req, res) => {
    try {
        const { sheetName, day, time } = req.query; // time is like '22:58'
        // console.log(`Received time: ${time}`);

        let timetable;
        let sheetId = await GoogleSpreadsheetModel.find();
        let spreadsheetId = sheetId[0].sheetId;

        // Fetching the timetable from the sheet
        const response = await sheets.spreadsheets.values.get({
            spreadsheetId,
            range: sheetName, // Adjust according to your sheet name
        });

        timetable = response.data.values;

        // Filter timetable by the selected day
        let dayWiseTimetable = timetable.filter((row) => row[0] === day);
        if (dayWiseTimetable.length === 0) {
            return res.status(404).json({ error: 'No timetable found for the selected day.' });
        }

        const timeSlots = timetable[0]; // The first row contains the time ranges

        // Find which time slot the selected time falls into
        let timeSlotIndex = -1;

        // Loop through each time slot (skip the first column header "Day/Time")
        for (let i = 1; i < timeSlots.length; i++) {
            const timeRange = timeSlots[i]; // e.g., '08:30 AM to 09:15 AM'
            const [startTime, endTime] = timeRange.split(' to ').map(t => moment(t, 'hh:mm A'));

            // Use moment to check if the selected time is within the range
            if (moment(time, 'HH:mm').isBetween(startTime, endTime, null, '[)')) {
                timeSlotIndex = i;
                break;
            }
        }

        if (timeSlotIndex === -1) {
            return res.status(404).json({ error: 'No class found at the selected time.' });
        }

        // Fetch the class information for the selected day and time slot
        const classInfo = dayWiseTimetable.map(row => row[timeSlotIndex]);
        // console.log(`Class at ${timeSlots[timeSlotIndex]}: ${classInfo}`);
        var timeWiseTimetableData = [];
        timeWiseTimetableData.push(timeSlots[timeSlotIndex]);

        for(let i of classInfo){
            timeWiseTimetableData.push(i);
        }

        // console.log(timeWiseTimetableData);


        return res.status(200).json({ timeWiseTimetableData });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Failed to fetch timetable based on time' });
    }
};

const getStudentsData = async (req, res) => {
    let students = await Student.find();
    // console.log(students);
    return res.status(200).json( {students} );
}

const getFacultyData = async (req, res) => {
    let faculties = await Faculty.find();
    return res.status(200).json( {faculties} );
}

const getRoomData = async (req, res) => {
    var roomsData = await Resource.find();
    var rooms = [];
    for(let i=0; i<roomsData.length; i++){
        let room = {
            _id:'',
            location:'',
            acs:'',
            chairs:'',
            benches:'',
            computers:'',
            fans:'',
            tubelights:'',
            projectors:'',
            availability:''
        }

        room._id = roomsData[i]._id;
        room.location = roomsData[i].location;
        room.acs = roomsData[i].acs;
        room.chairs = roomsData[i].chairs;
        room.benches = roomsData[i].benches;
        room.computers = roomsData[i].computers;
        room.fans = roomsData[i].fans;
        room.tubelights = roomsData[i].tubelights;
        room.projectors = roomsData[i].projectors;

        
        room.availability = "Available";

        rooms.push(room);
    }
    // console.log(rooms);
    return res.status(200).json( {rooms} );
}

const getStudentLocation = async (req, res) => {
    try {
        const { className, batch } = req.body;
        const spreadSheetTimeTable = await SpreadSheetTimeTable.findOne({ class: className });
        const timeArray = [];
        for(let i=0; i<spreadSheetTimeTable.weeklyTimetable.Monday[0].length; i++){
            timeArray.push(spreadSheetTimeTable.weeklyTimetable.Monday[0][i].time);
        }
        // console.log(timeArray);
        const currentDate = new Date();
        var day = currentDate.getDay();
        // day=3;

        if(day == 0){
            return res.status(200).json({ location: "Not available" });
        }

        var data = [];
        if(day ==1 ){
            data = spreadSheetTimeTable.weeklyTimetable.Monday;
        }
        else if(day == 2){
            data = spreadSheetTimeTable.weeklyTimetable.Tuesday;
        }
        else if(day == 3){
            data = spreadSheetTimeTable.weeklyTimetable.Wednesday;
        }
        else if(day == 4){
            data = spreadSheetTimeTable.weeklyTimetable.Thursday;
        }
        else if(day == 5){
            data = spreadSheetTimeTable.weeklyTimetable.Friday;
        }
        else if(day == 6){
            data = spreadSheetTimeTable.weeklyTimetable.Saturday;
        }

        // console.log(data);
        const currentTime = moment();
        // const currentTime = moment('08:45 AM', 'hh:mm A');

        let timeSlotIndex = -1;
        for (let i = 0; i < timeArray.length; i++) {
            const timeRange = timeArray[i]; // e.g., '08:30 AM to 09:15 AM'
            const [startTime, endTime] = timeRange.split(' to ').map(t => moment(t, 'hh:mm A'));

            // Use moment to check if the selected time is within the range
            if (currentTime.isBetween(startTime, endTime, null, '[)')) {
                timeSlotIndex = i;
                break;
            }
        }

        // console.log(data);


        if(timeSlotIndex==-1){
            return res.status(200).json({ location: "Not available" });
        }

        var location = "";
        for(let i=0; i<data.length; i++){
            if(data[i][timeSlotIndex].classbatch.includes(batch)){
                location = data[i][timeSlotIndex].location;
                break;
            }
        }

        if(location==""){
            for(let i=0; i<data.length; i++){
                if(data[i][timeSlotIndex].classbatch.includes(className)){
                    location = data[i][timeSlotIndex].location;
                    break;
                }
            }
        }

        if(location=="" || location=="-"){
            location = "Not available";
        }

        return res.status(200).json({ location });
    } catch (error) {
        console.log(error);
        
    }
}

const getFacultyLocation = async (req, res) => {
    try {
        const { facultyName } = req.body;
        // console.log(facultyName);
        const spreadSheetFacultyTimeTable = await SpreadSheetFacultyTimeTable.findOne({ facultyName });
        // console.log(spreadSheetFacultyTimeTable);
        if (!spreadSheetFacultyTimeTable) {
            return res.status(200).json({ location: "Not available" });
        }

        const timeArray = [];
        for(let i=0; i<spreadSheetFacultyTimeTable.weeklyTimetable.Monday[0].length; i++){
            timeArray.push(spreadSheetFacultyTimeTable.weeklyTimetable.Monday[0][i].time);
        }

        const currentDate = new Date();
        var day = currentDate.getDay();

        // day=2

        if(day == 0){
            return res.status(200).json({ location: "Not available" });
        }

        var data = [];
        if(day == 1 ){
            data = spreadSheetFacultyTimeTable.weeklyTimetable.Monday;
        }
        else if(day == 2){
            data = spreadSheetFacultyTimeTable.weeklyTimetable.Tuesday;
        }
        else if(day == 3){
            data = spreadSheetFacultyTimeTable.weeklyTimetable.Wednesday;
        }
        else if(day == 4){
            data = spreadSheetFacultyTimeTable.weeklyTimetable.Thursday;
        }
        else if(day == 5){
            data = spreadSheetFacultyTimeTable.weeklyTimetable.Friday;
        }
        else if(day == 6){
            data = spreadSheetFacultyTimeTable.weeklyTimetable.Saturday;
        }

        const currentTime = moment();
        // const currentTime = moment('11:40 AM', 'hh:mm A');

        let timeSlotIndex = -1;
        for (let i = 0; i < timeArray.length; i++) {
            const timeRange = timeArray[i]; // e.g., '08:30 AM to 09:15 AM'
            const [startTime, endTime] = timeRange.split(' to ').map(t => moment(t, 'hh:mm A'));

            // Use moment to check if the selected time is within the range
            if (currentTime.isBetween(startTime, endTime, null, '[)')) {
                timeSlotIndex = i;
                break;
            }
        }

        if(timeSlotIndex==-1){
            return res.status(200).json({ location: "Not available" });
        }

        var location = "";
        for(let i=0; i<data.length; i++){
            location = data[i][timeSlotIndex].location;
        }

        if(location=="" || location=="-"){
            location = "Not available";
        }

        res.status(200).json({location});
    } catch (error) {
        console.log(error);
    }
}

module.exports = {
    validateAdmin,
    validate,
    createClassBatch,
    getClasses,
    getBatches,
    createTimeTable,
    createSession,
    getTimes,
    addSheetId,
    getSheets,
    getTimetableBasedOnSheetName,
    getDayWiseTimetable,
    getTimetableBasedOnTime,
    getStudentsData,
    getStudentLocation,
    getFacultyData,
    getFacultyLocation,
    getRoomData
}